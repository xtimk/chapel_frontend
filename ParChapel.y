-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParChapel where
import AbsChapel
import LexChapel
import ErrM

}

%name pProgram Program
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '!=' { PT _ (TS _ 1) }
  '%' { PT _ (TS _ 2) }
  '&' { PT _ (TS _ 3) }
  '&&' { PT _ (TS _ 4) }
  '*' { PT _ (TS _ 5) }
  '+' { PT _ (TS _ 6) }
  ',' { PT _ (TS _ 7) }
  '-' { PT _ (TS _ 8) }
  '/' { PT _ (TS _ 9) }
  '<' { PT _ (TS _ 10) }
  '<<' { PT _ (TS _ 11) }
  '<=' { PT _ (TS _ 12) }
  '==' { PT _ (TS _ 13) }
  '>' { PT _ (TS _ 14) }
  '>=' { PT _ (TS _ 15) }
  '>>' { PT _ (TS _ 16) }
  '^' { PT _ (TS _ 17) }
  'do' { PT _ (TS _ 18) }
  'int' { PT _ (TS _ 19) }
  'ref' { PT _ (TS _ 20) }
  'while' { PT _ (TS _ 21) }
  '|' { PT _ (TS _ 22) }
  '||' { PT _ (TS _ 23) }
  L_POpenGraph { PT _ (T_POpenGraph _) }
  L_PCloseGraph { PT _ (T_PCloseGraph _) }
  L_POpenParenthesis { PT _ (T_POpenParenthesis _) }
  L_PCloseParenthesis { PT _ (T_PCloseParenthesis _) }
  L_PSemicolon { PT _ (T_PSemicolon _) }
  L_PIdent { PT _ (T_PIdent _) }
  L_PString { PT _ (T_PString _) }
  L_PChar { PT _ (T_PChar _) }
  L_PDouble { PT _ (T_PDouble _) }
  L_PInteger { PT _ (T_PInteger _) }
  L_PAssignmEq { PT _ (T_PAssignmEq _) }
  L_PAssignmPlus { PT _ (T_PAssignmPlus _) }

%%

POpenGraph :: { POpenGraph}
POpenGraph  : L_POpenGraph { POpenGraph (mkPosToken $1)}

PCloseGraph :: { PCloseGraph}
PCloseGraph  : L_PCloseGraph { PCloseGraph (mkPosToken $1)}

POpenParenthesis :: { POpenParenthesis}
POpenParenthesis  : L_POpenParenthesis { POpenParenthesis (mkPosToken $1)}

PCloseParenthesis :: { PCloseParenthesis}
PCloseParenthesis  : L_PCloseParenthesis { PCloseParenthesis (mkPosToken $1)}

PSemicolon :: { PSemicolon}
PSemicolon  : L_PSemicolon { PSemicolon (mkPosToken $1)}

PIdent :: { PIdent}
PIdent  : L_PIdent { PIdent (mkPosToken $1)}

PString :: { PString}
PString  : L_PString { PString (mkPosToken $1)}

PChar :: { PChar}
PChar  : L_PChar { PChar (mkPosToken $1)}

PDouble :: { PDouble}
PDouble  : L_PDouble { PDouble (mkPosToken $1)}

PInteger :: { PInteger}
PInteger  : L_PInteger { PInteger (mkPosToken $1)}

PAssignmEq :: { PAssignmEq}
PAssignmEq  : L_PAssignmEq { PAssignmEq (mkPosToken $1)}

PAssignmPlus :: { PAssignmPlus}
PAssignmPlus  : L_PAssignmPlus { PAssignmPlus (mkPosToken $1)}

Program :: { Program }
Program : Module { AbsChapel.Progr $1 }
Module :: { Module }
Module : ListExt { AbsChapel.Mod $1 }
ListExt :: { [Ext] }
ListExt : Ext { (:[]) $1 } | Ext ListExt { (:) $1 $2 }
Ext :: { Ext }
Ext : Declaration { AbsChapel.ExtDecl $1 }
    | Function { AbsChapel.ExtFun $1 }
Declaration :: { Declaration }
Declaration : Type PIdent PSemicolon { AbsChapel.NoAssgmDec $1 $2 $3 }
            | Type PIdent AssgnmOp Exp PSemicolon { AbsChapel.AssgmDec $1 $2 $3 $4 $5 }
Function :: { Function }
Function : Signature Body { AbsChapel.FunDec $1 $2 }
Signature :: { Signature }
Signature : Type PIdent FunctionParams { AbsChapel.Sign $1 $2 $3 }
FunctionParams :: { FunctionParams }
FunctionParams : POpenParenthesis ListParam PCloseParenthesis { AbsChapel.FunParams $1 $2 $3 }
ListParam :: { [Param] }
ListParam : {- empty -} { [] }
          | Param { (:[]) $1 }
          | Param ',' ListParam { (:) $1 $3 }
Param :: { Param }
Param : Type PIdent { AbsChapel.ParNoMode $1 $2 }
      | Mode Type PIdent { AbsChapel.ParWMode $1 $2 $3 }
Body :: { Body }
Body : POpenGraph ListBodyStatement PCloseGraph { AbsChapel.FunBlock $1 (reverse $2) $3 }
ListBodyStatement :: { [BodyStatement] }
ListBodyStatement : {- empty -} { [] }
                  | ListBodyStatement BodyStatement { flip (:) $1 $2 }
BodyStatement :: { BodyStatement }
BodyStatement : Statement { AbsChapel.Stm $1 }
              | Function PSemicolon { AbsChapel.Fun $1 $2 }
              | Declaration { AbsChapel.Decl $1 }
              | Body { AbsChapel.Block $1 }
Statement :: { Statement }
Statement : 'do' 'while' Body Guard { AbsChapel.DoWhile $3 $4 }
          | Exp PSemicolon { AbsChapel.StExp $1 $2 }
Guard :: { Guard }
Guard : POpenParenthesis Exp PCloseParenthesis { AbsChapel.SGuard $1 $2 $3 }
Type :: { Type }
Type : 'int' { AbsChapel.Tint }
AssgnmOp :: { AssgnmOp }
AssgnmOp : PAssignmEq { AbsChapel.AssgnEq $1 }
         | PAssignmPlus { AbsChapel.AssgnPlEq $1 }
Mode :: { Mode }
Mode : 'ref' { AbsChapel.RefMode }
Exp :: { Exp }
Exp : Exp AssgnmOp Exp4 { AbsChapel.EAss $1 $2 $3 } | Exp4 { $1 }
Exp4 :: { Exp }
Exp4 : Exp4 '||' Exp5 { AbsChapel.Elor $1 $3 } | Exp5 { $1 }
Exp5 :: { Exp }
Exp5 : Exp5 '&&' Exp6 { AbsChapel.Eland $1 $3 } | Exp6 { $1 }
Exp6 :: { Exp }
Exp6 : Exp6 '|' Exp7 { AbsChapel.Ebitor $1 $3 } | Exp7 { $1 }
Exp7 :: { Exp }
Exp7 : Exp7 '^' Exp8 { AbsChapel.Ebitexor $1 $3 } | Exp8 { $1 }
Exp8 :: { Exp }
Exp8 : Exp8 '&' Exp9 { AbsChapel.Ebitand $1 $3 } | Exp9 { $1 }
Exp9 :: { Exp }
Exp9 : Exp9 '==' Exp10 { AbsChapel.Eeq $1 $3 }
     | Exp9 '!=' Exp10 { AbsChapel.Eneq $1 $3 }
     | Exp10 { $1 }
Exp10 :: { Exp }
Exp10 : Exp10 '<' Exp11 { AbsChapel.Elthen $1 $3 }
      | Exp10 '>' Exp11 { AbsChapel.Egrthen $1 $3 }
      | Exp10 '<=' Exp11 { AbsChapel.Ele $1 $3 }
      | Exp10 '>=' Exp11 { AbsChapel.Ege $1 $3 }
      | Exp11 { $1 }
Exp11 :: { Exp }
Exp11 : Exp11 '<<' Exp12 { AbsChapel.Eleft $1 $3 }
      | Exp11 '>>' Exp12 { AbsChapel.Eright $1 $3 }
      | Exp12 { $1 }
Exp12 :: { Exp }
Exp12 : Exp12 '+' Exp13 { AbsChapel.Eplus $1 $3 }
      | Exp12 '-' Exp13 { AbsChapel.Eminus $1 $3 }
      | Exp13 { $1 }
Exp13 :: { Exp }
Exp13 : Exp13 '*' Exp14 { AbsChapel.Etimes $1 $3 }
      | Exp13 '/' Exp14 { AbsChapel.Ediv $1 $3 }
      | Exp13 '%' Exp14 { AbsChapel.Emod $1 $3 }
      | Exp14 { $1 }
Exp14 :: { Exp }
Exp14 : POpenParenthesis Exp PCloseParenthesis { AbsChapel.InnerExp $1 $2 $3 }
      | PIdent { AbsChapel.Evar $1 }
      | Constant { AbsChapel.Econst $1 }
      | PString { AbsChapel.Estring $1 }
Constant :: { Constant }
Constant : PDouble { AbsChapel.Efloat $1 }
         | PChar { AbsChapel.Echar $1 }
         | PInteger { AbsChapel.Eint $1 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

